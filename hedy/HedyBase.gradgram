module Hedy

import common.NUMBER -> NUMBER
import common.SIGNED_INT -> INT


level 1

_SPACE =  " "+
_COMMA = _SPACE? (","|"،") _SPACE? //support latin and arabic comma;s and always allow these to be surrounded by spaces
_EQUALS = _SPACE? "=" _SPACE? //always allow = to be surrounded by spaces

start = program: _EOL* (command _EOL+)* command?

command  
  = print: "print" (_SPACE text)?
  | ask: "ask" (_SPACE text)?
  | echo: "echo" (_SPACE text)?
  | turtle: turtle 
  | comment: _HASH /([^\n]+)/
  | @error error_invalid_space: _SPACE text?
  | @error error_invalid: textwithoutspaces text?

turtle 
  = forward: "forward" (_SPACE (text | NUMBER))?
  | turn: "turn" (_SPACE text)?

_EOL = "\r"?"\n"

text = text: /([^\n]+)/  //anything can be parsed except for a newline

textwithoutspaces = text: /([^\n *+-\/]+)/  //anything can be parsed except for spaces (plus: a newline)

// FH Sept 2021: More info on this variable format: https://www.unicode.org/reports/tr31/tr31-1.html
// Exact grammar stolen from: https://lark-parser.readthedocs.io/en/latest/classes.html

NAME = ID_START ID_CONTINUE*
ID_START = /[\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}_]+/
ID_CONTINUE = ID_START | /[\p{Mn}\p{Mc}\p{Nd}\p{Pc}·]+/

// Internal symbol added by the preprocess_blocks function to indicate the end of blocks
_END_BLOCK = "end-block"

level 2

remove echo

_IS = "is" | "="

command 
  = assign: var _SPACE _IS _SPACE text  
  | @override print: "print" (_SPACE _print_argument)?
  | @override ask: var _SPACE _IS _SPACE "ask" (_SPACE + (_SPACE | text_ask | punctuation)*)?
  | sleep: "sleep" (_SPACE INT)?
  | @error error_ask_dep_2: "ask" (_SPACE error_text_dep_2)?
  | @error error_echo_dep_2: "echo" (_SPACE error_text_dep_2)?
  | @error error_text_dep_2: /([^\n]+)/ -> text //anything can be parsed except for a newline
  

turtle
  = @override forward: "forward" (_SPACE (INT | textwithoutspaces))? 
  | @override turn: "turn" (_SPACE (textwithoutspaces))? -> turn

_print_argument = print_arg: (_SPACE | textwithoutspaces | punctuation)*

textwithoutspaces = 
  @override text: /([^\r\n!?. ]+)/  //anything can be parsed except for spaces (plus: a newline and a comma for list separators)

text = @override text: /([^\r\n,!?،.]+)/  //todo FH, feb 2022 this can go to level 3 cause in (the new) level 2 it is allowed to have commas, lists are now introduced in level 2

text_ask = text: /([^\r\n!?.]+)/ //as ask may contain commas (punctionation is still needed separately so they can be printed after vars)

punctuation = punctuation: PUNCTUATION 
PUNCTUATION =  _EXCLAMATION_MARK | _QUESTION_MARK | _PERIOD //uppercase places tokens in tree

var = var: NAME 

level 3


command 
  = @override assign: var _SPACE _IS _SPACE (list_access | text) 
  | assign_list: var _SPACE _IS _SPACE text_list (_COMMA text_list)+
  | add: "add" _SPACE some_spaces _SPACE "to" _SPACE var
  | remove: "remove" _SPACE some_spaces _SPACE "from" _SPACE var
  

   
_print_argument 
  = @override print_arg: (_SPACE | list_access | textwithoutspaces | punctuation)*


text_list = text: /([^\r\n,،]+)/  // list elements may contain punctuation but not commas or course, these are separators

list_access = list_access: var _SPACE "at" _SPACE (INT | random) 

turtle 
  = @override forward: "forward" (_SPACE (INT | list_access | textwithoutspaces))?  
  | @override turn: "turn" (_SPACE (list_access | textwithoutspaces))?

// FH, jan 22: not exactly sure why this works, while textwithoutspaces parses the whole line in add/remove
// leaving this for now
some_spaces = text_with_spaces: /([^\r\n!?. ]+)/ (_SPACE /([^\r\n!?. ]+)/)*

level 4

// redifining it entirely since it has many order-depending rules (e.g ask_no_quotes should be after ask and before assign)
command
  = @override print:  "print" (_SPACE _print_argument)?
  | @override ask:  var _SPACE _IS _SPACE "ask" (_SPACE _print_argument)?
  | @error error_ask_no_quotes: var _SPACE _IS _SPACE "ask" _SPACE text  -> error_ask_nq
  | @override assign: var _SPACE _IS _SPACE (list_access | text) // TVDS: ugly, but needed for ordering. 
  | @error error_print_no_quotes: "print" _SPACE text -> error_print_nq


_print_argument = @override print_arg: (_SPACE | list_access | quoted_text | var_access)*

// we need a separate rule for a var when used in a print argument
// it parses the same, but should not be counted towards lookup table creation
var_access = NAME


//anything can be parsed except for spaces, and a newlines and commas for list separators
textwithoutspaces = @override text: /([^\r\n, *+-\/]+)/ 

//anything can be parsed except for a newline and a comma for list separators
//punctuation does not need to be treated differently anymore
text = @override text: /([^\n,]+)/ 

quoted_text_no_escape = text: /'([^']*)'/ //simply all between quotes should this be used at earlier levels?
quoted_text = text: /'((?:[^\\']|\\.)*)'/  //text can be between single quotes, but quotes may be escaped with \


level 5


remove error_invalid

program = _EOL* (command | error_invalid) (_SPACE)* (_EOL+ (command | error_invalid) (_SPACE)*)* _EOL* //lines may end on spaces and might be separated by many newlines



command
  = ifelse: _IF _SPACE condition (_SPACE|_EOL*) command (_SPACE|_EOL*) _ELSE (_SPACE|_EOL*) command
  | ifs: _IF _SPACE condition (_SPACE|_EOL*) command //'if' cannot be used in Python, hence the name of the rule is 'ifs'
  | list_access_var: var _SPACE _IS _SPACE var _SPACE "at" _SPACE (INT | random)
  | assign_list: var _SPACE _IS _SPACE textwithspaces (_COMMA textwithspaces)+
  | assign: var _SPACE _IS _SPACE textwithspaces
  | @error error_invalid: textwithoutspaces (_SPACE textwithspaces)?
  | @error error_print_no_quotes: "print" _SPACE (textwithoutspaces | list_access | var) (_SPACE (textwithoutspaces | list_access | var))*  -> error_print_nq

    
condition
  = equality_check: textwithoutspaces _SPACE _IS _SPACE textwithoutspaces (_SPACE textwithoutspaces)* //TODO FH nov 2021: not super pretty that this is textwithoutquotes for both a var and also a textual constant, level 12 handles this nicer now, could be done here too
  | in_list_check: textwithoutspaces _SPACE _IN _SPACE var

nospace = /[^\n, ]/

textwithspaces
  = text: /(?:[^\n،, ]| (?!else))+/  //anything can be parsed except for a newline and a comma for list separators

//a space is allowed, of course but it may not be followed by an else. The part " (?!else))" means space not followed by (negative look ahead) else
//That is because allowing else in strings leads to issue #303

textwithoutspaces
  = @override text: /(?:[^\n،, ei]|e(?!lse)|i(?!f))+/ 
//anything can be parsed except for spaces (plus: a newline and a comma for list separators)
//the part e(?!lse)|i(?!f)) means e not followed by lse, and i not followed by f
// this is because allowing else and if in invalid leads to ambiguity in the grammar                                            

level 6

remove ask, list_access, assign, assign_list, equality_check


_print_argument = @override print_arg: (_SPACE | quoted_text | list_access | var_access | sum)*

//splitting  these commands into two rules, one for equals and one for is so they can be properly handled in the translator


command 
  = ask_is: var _SPACE _IS _SPACE "ask" (_SPACE _print_argument)?
  | ask_equals: var _EQUALS "ask" (_SPACE _print_argument)?
  | list_access_var_equals: var _EQUALS var _SPACE "at" _SPACE (INT | random)
  | list_access_var_is: var _SPACE _IS _SPACE var _SPACE "at" _SPACE (INT | random)
  | assign_is: var _SPACE _IS _SPACE sum | var _SPACE _IS _SPACE textwithoutspaces
  | assign_equals: var _EQUALS sum | var _EQUALS textwithoutspaces
  | assign_list_is: var _SPACE _IS _SPACE textwithspaces (_COMMA textwithspaces)+
  | assign_list_equals: var _EQUALS textwithspaces (_COMMA textwithspaces)+
  

condition
  = equality_check_is: textwithoutspaces _SPACE _IS _SPACE textwithoutspaces (_SPACE textwithoutspaces)*
  | equality_check_equals: textwithoutspaces _EQUALS textwithoutspaces (_SPACE textwithoutspaces)*


sum 
  = product 
  | addition: sum _SPACE* "+" _SPACE* product  
  | subtraction: sum _SPACE* "-" _SPACE* product
  
product  
  = atom
  | multiplication: product _SPACE* "*" _SPACE* atom 
  | division: product _SPACE* "/" _SPACE* atom 

atom = INT 
  | var_access 
  | @error error_unsupported_number: /([-+]?(\d+[\.,]\d+))/ -> error_unsupported_number
   
   //TODO: means we cannot assign strings with spaces? would we want that?

textwithoutspaces
  = @override text: /(?:[^\n, *+\-\/ei]|e(?!lse)|i(?!f))+/  //new cause in level 5 calculation elements need to be escaped too                
  

level 7

remove error_print_no_quotes

command
 = repeat: "repeat" _SPACE (INT | var) _SPACE "times" _SPACE command

level 8

remove ifelse, ifs


command 
  = ifs: "if" _SPACE condition _EOL (_SPACE command) (_EOL _SPACE command)* _EOL _END_BLOCK
  | elses: _EOL (_SPACE)* "else" (_SPACE)* _EOL (_SPACE command) (_EOL _SPACE command)* _EOL _END_BLOCK
  | @override repeat: "repeat" _SPACE (INT | var) _SPACE "times" _EOL (_SPACE command) (_EOL _SPACE command)* _EOL _END_BLOCK



level 9

// no additions to the grammar because we now allow nested blocks
// which is done in the transpiler

level 10

//TODO: Maybe this should be called for_list instead of repeat_list? I find thi a bit confusing myself (FH, Nov 2021)
command
  = repeat_list: "for" _SPACE var _SPACE "in" _SPACE var _EOL (_SPACE command) (_EOL _SPACE command)* _EOL _END_BLOCK
  
level 11

remove repeat, turtle

command
  = for_loop: "for" _SPACE (NAME | var) _SPACE "in" _SPACE _RANGE _SPACE (INT | var) _SPACE "to" _SPACE (INT | var) _EOL (_SPACE command) (_EOL _SPACE command)* _EOL _END_BLOCK
  



