module Hedy

import common.NUMBER -> NUMBER
import common.SIGNED_INT -> INT


level 1

_SPACE =  " "+
_COMMA = _SPACE? (","|"،") _SPACE? //support latin and arabic comma;s and always allow these to be surrounded by spaces
_EQUALS = _SPACE? "=" _SPACE? //always allow = to be surrounded by spaces

start = program: _EOL* (command _EOL+)* command?

command  
  = print: _PRINT (_SPACE text)?
  | ask: _ASK (_SPACE text)?
  | echo: _ECHO (_SPACE text)?
  | turtle: turtle 
  | comment: _HASH /([^\n]+)/
  | @error invalid_space: _SPACE text?
  | @error invalid: textwithoutspaces text?

turtle 
  = forward: _FORWARD (_SPACE (text | NUMBER))?
  | turn: _TURN (_SPACE text)?

_EOL = "\r"?"\n"

text = text: /([^\n]+)/  //anything can be parsed except for a newline

textwithoutspaces = text: /([^\n *+-\/]+)/  //anything can be parsed except for spaces (plus: a newline)

// FH Sept 2021: More info on this variable format: https://www.unicode.org/reports/tr31/tr31-1.html
// Exact grammar stolen from: https://lark-parser.readthedocs.io/en/latest/classes.html

NAME = ID_START ID_CONTINUE*
ID_START = /[\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}_]+/
ID_CONTINUE = ID_START | /[\p{Mn}\p{Mc}\p{Nd}\p{Pc}·]+/

// Internal symbol added by the preprocess_blocks function to indicate the end of blocks
_END_BLOCK = "end-block"

level 2

remove echo

command 
  = assign: var _SPACE _IS _SPACE text  
  | @override print: _PRINT (_SPACE _print_argument)?
  | @override ask: var _SPACE _IS _SPACE _ASK (_SPACE + (_SPACE | text_ask | punctuation)*)?
  | sleep: _SLEEP (_SPACE INT)?
  | @error ask_dep_2: _ASK (_SPACE error_text_dep_2)?
  | @error echo_dep_2: _ECHO (_SPACE error_text_dep_2)?
  | @error text_dep_2: /([^\n]+)/ -> text //anything can be parsed except for a newline
  

turtle
  = @override forward: _FORWARD (_SPACE (INT | textwithoutspaces))? 
  | @override turn: _TURN (_SPACE (textwithoutspaces))? -> turn

_print_argument = print_arg: (_SPACE | textwithoutspaces | punctuation)*

textwithoutspaces = 
  @override text: /([^\r\n!?. ]+)/  //anything can be parsed except for spaces (plus: a newline and a comma for list separators)

text = @override text: /([^\r\n,!?،.]+)/  //todo FH, feb 2022 this can go to level 3 cause in (the new) level 2 it is allowed to have commas, lists are now introduced in level 2

text_ask = text: /([^\r\n!?.]+)/ //as ask may contain commas (punctionation is still needed separately so they can be printed after vars)

punctuation = punctuation: PUNCTUATION 
PUNCTUATION =  _EXCLAMATION_MARK | _QUESTION_MARK | _PERIOD //uppercase places tokens in tree

var = var: NAME 

level 3


command 
  = @override assign: var _SPACE _IS _SPACE (list_access | text) 
  | assign_list: var _SPACE _IS _SPACE text_list (_COMMA text_list)+
  | add: _ADD_LIST _SPACE some_spaces _SPACE _TO_LIST _SPACE var
  | remove: _REMOVE _SPACE some_spaces _SPACE _FROM _SPACE var
  

   
_print_argument 
  = @override print_arg: (_SPACE | list_access | textwithoutspaces | punctuation)*


text_list = text: /([^\r\n,،]+)/  // list elements may contain punctuation but not commas or course, these are separators

list_access = list_access: var _SPACE _AT _SPACE (INT | random) 

turtle 
  = @override forward: _FORWARD (_SPACE (INT | list_access | textwithoutspaces))?  
  | @override turn: _TURN (_SPACE (list_access | textwithoutspaces))?

// FH, jan 22: not exactly sure why this works, while textwithoutspaces parses the whole line in add/remove
// leaving this for now
some_spaces = text_with_spaces: /([^\r\n!?. ]+)/ (_SPACE /([^\r\n!?. ]+)/)*

level 4

// redifining it entirely since it has many order-depending rules (e.g ask_no_quotes should be after ask and before assign)
command
  = @override print:  _PRINT (_SPACE _print_argument)?
  | @override ask:  var _SPACE _IS _SPACE _ASK (_SPACE _print_argument)?
  | @error ask_no_quotes: var _SPACE _IS _SPACE _ASK _SPACE text  -> error_print_nq
  | @override assign: var _SPACE _IS _SPACE (list_access | text) // TVDS: ugly, but needed for ordering. 
  | @error print_no_quotes: _PRINT _SPACE text -> error_print_nq


_print_argument = @override print_arg: (_SPACE | list_access | quoted_text | var_access)*

// we need a separate rule for a var when used in a print argument
// it parses the same, but should not be counted towards lookup table creation
var_access = NAME


//anything can be parsed except for spaces, and a newlines and commas for list separators
textwithoutspaces = @override text: /([^\r\n, *+-\/]+)/ 

//anything can be parsed except for a newline and a comma for list separators
//punctuation does not need to be treated differently anymore
text = @override text: /([^\n,]+)/ 

quoted_text_no_escape = text: /'([^']*)'/ //simply all between quotes should this be used at earlier levels?
quoted_text = text: /'((?:[^\\']|\\.)*)'/  //text can be between single quotes, but quotes may be escaped with \


level 5

program = _EOL* (command | error_invalid) (_SPACE)* (_EOL+ (command | error_invalid) (_SPACE)*)* _EOL* //lines may end on spaces and might be separated by many newlines


remove error_invalid

command
  = ifelse: _IF _SPACE condition (_SPACE|_EOL*) command (_SPACE|_EOL*) _ELSE (_SPACE|_EOL*) command
  | ifs: _IF _SPACE condition (_SPACE|_EOL*) command //'if' cannot be used in Python, hence the name of the rule is 'ifs'
  | list_access_var: var _SPACE _IS _SPACE var _SPACE _AT _SPACE (INT | random)
  | assign_list: var _SPACE _IS _SPACE textwithspaces (_COMMA textwithspaces)+
  | assign: var _SPACE _IS _SPACE textwithspaces
  | @error invalid: textwithoutspaces (_SPACE textwithspaces)?
  | @error print_no_quotes: _PRINT _SPACE (textwithoutspaces | list_access | var) (_SPACE (textwithoutspaces | list_access | var))*  -> error_print_nq

    
condition
  = equality_check: textwithoutspaces _SPACE _IS _SPACE textwithoutspaces (_SPACE textwithoutspaces)* //TODO FH nov 2021: not super pretty that this is textwithoutquotes for both a var and also a textual constant, level 12 handles this nicer now, could be done here too
  | in_list_check: textwithoutspaces _SPACE _IN _SPACE var

nospace = /[^\n, ]/

textwithspaces
  = text: /(?:[^\n،, ]| (?!else))+/  //anything can be parsed except for a newline and a comma for list separators

//a space is allowed, of course but it may not be followed by an else. The part " (?!else))" means space not followed by (negative look ahead) else
//That is because allowing else in strings leads to issue #303

textwithoutspaces
  = @override text: /(?:[^\n،, ei]|e(?!lse)|i(?!f))+/ 
//anything can be parsed except for spaces (plus: a newline and a comma for list separators)
//the part e(?!lse)|i(?!f)) means e not followed by lse, and i not followed by f
// this is because allowing else and if in invalid leads to ambiguity in the grammar                                            

